#!/usr/bin/env python3
"""
test finds all files with extension 'test' in the directory 'data' and runs
them.

Tests are expected to have the format:

    <server_command>
    <client_count>
    <client_command>...
    <input_count>
    <input>...
    <server_error_code>
    <client_error_code>...

test runs the server-command and all the client-commands. All the input is then
written to the server's STDIN. The server is closed. Finally, all the
error-codes are checked.

An example passing test is:

    ./server 5050
    1
    ./client 8080 127.0.0.1 5050
    1
    message
    0
    0
"""

import glob
import subprocess
import time


def run(cmd):
    return subprocess.Popen(
        cmd.split(),
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)


def parse(handle):
    lines = [line[:-1] for line in handle if not line.startswith('#')]
    server = lines[0]
    client_count = int(lines[1])
    input_start = 2 + client_count
    clients = lines[2:input_start]
    input_count = int(lines[input_start])
    input_lines = lines[input_start + 1:input_start + 1 + input_count]
    error_code_start = input_start + 1 + input_count
    error_codes = [int(error_code) for error_code in lines[error_code_start:]]
    return server, clients, input_lines, error_codes


TERMINATED_ERROR_CODE = -15


def assert_result(path, actual, expected):
    try:
        assert actual[0] == expected[0]
        assert_error(path, actual[1], expected[1])
    except AssertionError as error:
        print('Error in', path)
        print()
        print('Actual output:')
        print(actual[0])
        print()
        print('Expected output:')
        print(expected[0])
        print()
        print('Actual error-code:')
        print(actual[1])
        print()
        print('Expected error-code:')
        print(expected[1])
        print()
        raise error


def assert_error(path, actual, expected):
    if actual == TERMINATED_ERROR_CODE:
        actual = 0
    try:
        assert actual == expected
    except AssertionError as error:
        print('Error in', path)
        print()
        print('Actual error-code:')
        print(actual)
        print()
        print('Expected error-code:')
        print(expected)
        print()


def wait():
    time.sleep(0.1)


def test(base):
    for path in glob.glob('{}/*.test'.format(base)):
        with open(path) as handle:
            server, clients, input_lines, error_codes = parse(handle)

            server_result = run(server)
            wait()  # Give command time to start.

            client_results = [run(client) for client in clients]
            wait()  # Give commands time to start.

            for line in input_lines:
                server_result.stdin.write((line + '\n').encode())
                server_result.stdin.flush()
            wait()  # Give message time to go across network.

            server_result.terminate()
            while server_result.poll() is None:
                wait()  # Wait until command terminates.

            for result in client_results:
                result.terminate()
                while result.poll() is None:
                    wait()  # Wait until command terminates.

            assert_error(path, server_result.returncode, error_codes[0])
            for i, result in enumerate(client_results):
                raw_out, _ = result.communicate()
                out = raw_out.decode('utf-8').split('\n')[:-1]
                assert_result(path, (out, result.returncode),
                              (input_lines, error_codes[i + 1]))


if __name__ == '__main__':
    test('data')
