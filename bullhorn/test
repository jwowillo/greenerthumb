#!/usr/bin/env python3
"""
test finds all files with extension 'test' in the directory 'data' and runs
them.

Tests are expected to have the format:

    <server_command>
    <client_count>
    <client_command>...
    <server_input_count>
    <server_input>...
    <server_output_count>
    <server_output>...
    <clients_input_count>
    <clients_input>...
    <clients_output_count>
    <clients_output>...
    <server_error_code>
    <client_error_code>...

test runs the server-command and all the client-commands. All the input is then
written to the server or client's STDIN based on the value o
<server_or_client>. The server is closed. Finally, all the error-codes are
checked.

An example passing test is:

    ./server 5050
    1
    ./client 8080 127.0.0.1 5050 CHECK
    1
    message
    0
    0
    1
    message
    0
    0
"""

import glob
import subprocess
import time


def run(cmd):
    return subprocess.Popen(
        cmd.split(),
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)


def parse(handle):
    lines = [line[:-1] for line in handle if not line.startswith('#')]

    server = lines[0]
    client_count = int(lines[1])
    clients = lines[2:2 + client_count]

    lines = lines[2 + client_count:]

    server_input_count = int(lines[0])
    server_input = lines[1:1 + server_input_count]

    lines = lines[1 + server_input_count:]

    server_output_count = int(lines[0])
    server_output = lines[1:1 + server_output_count]

    lines = lines[1 + server_output_count:]

    client_input_count = int(lines[0])
    client_input = lines[1:1 + client_input_count]

    lines = lines[1 + client_input_count:]

    client_output_count = int(lines[0])
    client_output = lines[1:1 + client_output_count]

    lines = lines[1 + client_output_count:]

    error_codes = [int(line) for line in lines]

    return (server, clients, server_input, server_output, client_input,
            client_output, error_codes)


def assert_result(path, actual_server_output, expected_server_output,
                  actual_clients_output, expected_client_output,
                  actual_error_codes, expected_error_codes):
    actual_error_codes = [convert_error(error) for error in actual_error_codes]
    try:
        assert actual_server_output == expected_server_output
        for output in actual_clients_output:
            assert output == expected_client_output
        assert actual_error_codes == expected_error_codes
    except AssertionError as error:
        print('Error in', path)
        print()
        print('Actual server output:')
        print(actual_server_output)
        print()
        print('Expected server output:')
        print(expected_server_output)
        print()
        print('Actual clients output:')
        print(actual_clients_output)
        print()
        print('Expected client output:')
        print(expected_client_output)
        print()
        print('Actual error-codes:')
        print(actual_error_codes)
        print()
        print('Expected error-codes:')
        print(expected_error_codes)
        print()
        raise error


def convert_error(error):
    TERMINATED_ERROR_CODE = -15
    if error == TERMINATED_ERROR_CODE:
        error = 0
    return error


def wait():
    time.sleep(0.1)


def test(base):
    for path in glob.glob('{}/*.test'.format(base)):
        with open(path) as handle:
            (server, clients, server_input, server_output, client_input,
             client_output, error_codes) = parse(handle)

            server_result = run(server)

            client_results = [run(client) for client in clients]

            wait()  # Give programs time to start.

            for line in server_input:
                server_result.stdin.write((line + '\n').encode())
            server_result.stdin.flush()

            for client in client_results:
                for line in client_input:
                    client.stdin.write((line + '\n').encode())
                client.stdin.flush()

            wait()  # Give messages time to go across network.

            server_result.terminate()
            server_result.wait()
            for client in client_results:
                client.terminate()
                client.wait()

            actual_server_output = [
                line.decode('utf-8')[:-1] for line in server_result.stdout
            ]
            actual_clients_output = []
            for client in client_results:
                actual_clients_output.append(
                    [line.decode('utf-8')[:-1] for line in client.stdout])

            actual_error_codes = [server_result.returncode]
            for client in client_results:
                actual_error_codes.append(client.returncode)

            assert_result(path, actual_server_output, server_output,
                          actual_clients_output, client_output,
                          actual_error_codes, error_codes)


if __name__ == '__main__':
    test('data')
